# Phase 3: 레벨 디자인

> 기간: 6주 | 맵, 던전, 퍼즐, 기믹 구현

---

## 목표
- 타일맵 기반 레벨 제작
- 씬 전환 및 카메라 시스템
- 퍼즐 및 환경 기믹 구현
- 던전 시스템 구현

---

## Week 1-2: 맵 시스템

### 타일맵 설정

#### 타일 팔레트 구성
```
Tiles/
├── Floor/          # 바닥
│   ├── tile_wood.png
│   ├── tile_stone.png
│   └── tile_metal.png
├── Wall/           # 벽
│   ├── wall_wood.png
│   └── wall_stone.png
├── Decoration/     # 장식
│   ├── deco_clock.png
│   └── deco_gear.png
└── Collision/      # 충돌용
    └── collision_block.png
```

#### 레이어 구성
| 레이어 | 정렬 순서 | 용도 |
|--------|-----------|------|
| Background | -100 | 배경 |
| Floor | 0 | 바닥 타일 |
| Decoration_Back | 10 | 뒤 장식 |
| Entities | 50 | 플레이어, 적 |
| Decoration_Front | 100 | 앞 장식 |
| UI | 1000 | HUD |

---

### RoomController.cs

```csharp
using UnityEngine;
using Cinemachine;

public class RoomController : MonoBehaviour
{
    [Header("Room Settings")]
    public string roomId;
    public Bounds roomBounds;
    
    [Header("Camera")]
    [SerializeField] private CinemachineVirtualCamera roomCamera;
    [SerializeField] private PolygonCollider2D cameraBounds;
    
    [Header("Enemies")]
    [SerializeField] private Transform[] spawnPoints;
    [SerializeField] private EnemySpawnData[] enemies;
    
    [Header("Doors")]
    [SerializeField] private Door[] doors;
    
    private bool _isCleared = false;
    private int _enemiesRemaining;
    
    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            EnterRoom();
        }
    }
    
    private void EnterRoom()
    {
        // 카메라 전환
        roomCamera.Priority = 10;
        
        // 적 스폰
        SpawnEnemies();
        
        // 문 잠금
        foreach (var door in doors)
            door.Lock();
    }
    
    private void SpawnEnemies()
    {
        _enemiesRemaining = 0;
        
        foreach (var data in enemies)
        {
            for (int i = 0; i < data.count; i++)
            {
                var spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];
                var enemy = Instantiate(data.prefab, spawnPoint.position, Quaternion.identity);
                enemy.GetComponent<EnemyBase>().onDeath += OnEnemyDeath;
                _enemiesRemaining++;
            }
        }
        
        if (_enemiesRemaining == 0)
            ClearRoom();
    }
    
    private void OnEnemyDeath()
    {
        _enemiesRemaining--;
        if (_enemiesRemaining <= 0)
            ClearRoom();
    }
    
    private void ClearRoom()
    {
        _isCleared = true;
        
        foreach (var door in doors)
            door.Unlock();
        
        // 보상 드롭
        SpawnReward();
    }
    
    private void SpawnReward()
    {
        // 클리어 보상
    }
}

[System.Serializable]
public class EnemySpawnData
{
    public GameObject prefab;
    public int count;
    public float delay;
}
```

---

### Door.cs

```csharp
using UnityEngine;

public class Door : MonoBehaviour, IInteractable
{
    [Header("Door Settings")]
    public string targetSceneName;
    public string targetSpawnPoint;
    
    [Header("State")]
    [SerializeField] private bool isLocked = false;
    [SerializeField] private bool requiresKey = false;
    [SerializeField] private string requiredKeyId;
    
    [Header("Visuals")]
    [SerializeField] private Animator animator;
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private Sprite lockedSprite;
    [SerializeField] private Sprite unlockedSprite;
    
    public void Interact()
    {
        if (isLocked)
        {
            if (requiresKey && HasKey())
            {
                Unlock();
            }
            else
            {
                // 잠겨있음 메시지
                UIManager.Instance.ShowMessage("잠겨 있다...");
            }
            return;
        }
        
        // 씬 전환
        SceneLoader.Instance.LoadScene(targetSceneName, targetSpawnPoint);
    }
    
    public void Lock()
    {
        isLocked = true;
        animator.SetBool("IsLocked", true);
        spriteRenderer.sprite = lockedSprite;
    }
    
    public void Unlock()
    {
        isLocked = false;
        animator.SetTrigger("Unlock");
        spriteRenderer.sprite = unlockedSprite;
    }
    
    private bool HasKey()
    {
        return InventoryManager.Instance.HasItem(requiredKeyId);
    }
}

public interface IInteractable
{
    void Interact();
}
```

---

### 카메라 설정 (Cinemachine)

```csharp
using UnityEngine;
using Cinemachine;

public class CameraManager : MonoBehaviour
{
    public static CameraManager Instance { get; private set; }
    
    [SerializeField] private CinemachineVirtualCamera mainCamera;
    [SerializeField] private CinemachineConfiner2D confiner;
    
    private void Awake()
    {
        Instance = this;
    }
    
    public void SetBounds(PolygonCollider2D bounds)
    {
        confiner.m_BoundingShape2D = bounds;
    }
    
    public void Shake(float intensity, float duration)
    {
        StartCoroutine(ShakeRoutine(intensity, duration));
    }
    
    private System.Collections.IEnumerator ShakeRoutine(float intensity, float duration)
    {
        var noise = mainCamera.GetCinemachineComponent<CinemachineBasicMultiChannelPerlin>();
        noise.m_AmplitudeGain = intensity;
        
        yield return new WaitForSeconds(duration);
        
        noise.m_AmplitudeGain = 0;
    }
}
```

---

## Week 3-4: 챕터 맵 제작

### 맵 체크리스트 (11_level_data.md 참조)

#### 프롤로그: 다락방
| 구역 | 크기 | 적 | 기믹 | 이벤트 |
|------|------|-----|------|--------|
| 메인 룸 | 15×10 | - | 튜토리얼 | 시작 |
| 창고 | 10×8 | 틱톡커 ×2 | 상자 | 시프트 학습 |
| 탈출로 | 20×5 | 망령 ×1 | 추격 | 회피 학습 |

#### 1장: 미래 도시
| 구역 | 크기 | 적 | 기믹 |
|------|------|-----|------|
| 폐허 거리 A | 30×20 | 틱톡커 ×4 | - |
| 폐허 거리 B | 25×20 | 틱톡커 ×2, 글리치 ×2 | 무너진 빌딩 |
| 치안국 로비 | 20×15 | 글리치 ×3 | 레이 이벤트 |
| 치안국 2층 | 25×15 | 틱톡커 ×3, 먹는자 ×1 | 대화 |
| 지하 통로 | 40×10 | 망령 ×4 | 어둠 |
| 보스 구역 | 20×20 | 시간 먹는 자 | - |

---

## Week 5-6: 퍼즐 & 기믹

### TimeReversePuzzle.cs (시간 역전 퍼즐)

```csharp
using UnityEngine;
using System.Collections.Generic;

public class TimeReversePuzzle : MonoBehaviour, IRewindable
{
    [Header("Puzzle Settings")]
    [SerializeField] private List<PuzzleState> states;
    [SerializeField] private int currentStateIndex;
    
    [Header("Visuals")]
    [SerializeField] private SpriteRenderer spriteRenderer;
    [SerializeField] private Animator animator;
    
    private bool _isSolved = false;
    
    public void Rewind(float duration)
    {
        if (_isSolved) return;
        
        // 이전 상태로
        currentStateIndex = Mathf.Max(0, currentStateIndex - 1);
        ApplyState(currentStateIndex);
        
        CheckSolution();
    }
    
    public void Advance()
    {
        if (_isSolved) return;
        
        // 다음 상태로
        currentStateIndex = Mathf.Min(states.Count - 1, currentStateIndex + 1);
        ApplyState(currentStateIndex);
        
        CheckSolution();
    }
    
    private void ApplyState(int index)
    {
        var state = states[index];
        spriteRenderer.sprite = state.sprite;
        animator.SetInteger("State", index);
    }
    
    private void CheckSolution()
    {
        if (currentStateIndex == 0) // 가장 과거 상태
        {
            _isSolved = true;
            OnSolved();
        }
    }
    
    private void OnSolved()
    {
        Debug.Log("Puzzle Solved!");
        // 문 열기, 보상 등
        EventBus.Publish(new OnPuzzleSolved { puzzleId = gameObject.name });
    }
}

[System.Serializable]
public class PuzzleState
{
    public string stateName;
    public Sprite sprite;
}

public struct OnPuzzleSolved { public string puzzleId; }
```

---

### TimeLayerSystem.cs (과거/현재 레이어)

```csharp
using UnityEngine;
using System.Collections.Generic;

public class TimeLayerSystem : MonoBehaviour
{
    public static TimeLayerSystem Instance { get; private set; }
    
    [Header("Layers")]
    [SerializeField] private GameObject presentLayer;
    [SerializeField] private GameObject pastLayer;
    
    [Header("Transition")]
    [SerializeField] private float transitionDuration = 0.5f;
    
    public TimeLayer CurrentLayer { get; private set; } = TimeLayer.Present;
    
    private void Awake()
    {
        Instance = this;
    }
    
    public void SwitchToLayer(TimeLayer layer)
    {
        if (CurrentLayer == layer) return;
        
        StartCoroutine(TransitionRoutine(layer));
    }
    
    private System.Collections.IEnumerator TransitionRoutine(TimeLayer targetLayer)
    {
        // 페이드 아웃
        yield return StartCoroutine(FadeOut());
        
        // 레이어 전환
        presentLayer.SetActive(targetLayer == TimeLayer.Present);
        pastLayer.SetActive(targetLayer == TimeLayer.Past);
        CurrentLayer = targetLayer;
        
        // 페이드 인
        yield return StartCoroutine(FadeIn());
        
        EventBus.Publish(new OnTimeLayerChanged { newLayer = targetLayer });
    }
    
    private System.Collections.IEnumerator FadeOut()
    {
        // 화면 효과
        yield return new WaitForSeconds(transitionDuration / 2);
    }
    
    private System.Collections.IEnumerator FadeIn()
    {
        yield return new WaitForSeconds(transitionDuration / 2);
    }
}

public enum TimeLayer { Present, Past }
public struct OnTimeLayerChanged { public TimeLayer newLayer; }
```

---

### EnvironmentHazard.cs

```csharp
using UnityEngine;

public class EnvironmentHazard : MonoBehaviour
{
    [Header("Hazard Settings")]
    public HazardType type;
    public int damage;
    public float interval = 1f;
    
    private float _lastDamageTime;
    
    private void OnTriggerStay2D(Collider2D other)
    {
        if (!other.CompareTag("Player")) return;
        
        if (Time.time - _lastDamageTime < interval) return;
        _lastDamageTime = Time.time;
        
        var stats = other.GetComponent<PlayerStats>();
        
        switch (type)
        {
            case HazardType.Gear:
                stats.TakeDamage(damage);
                break;
            case HazardType.Void:
                stats.TakeDamage(9999); // 즉사
                break;
            case HazardType.TimeAccel:
                // 가속 상태이상
                break;
            case HazardType.TimeStop:
                // 정지 상태이상
                break;
        }
    }
}

public enum HazardType { Gear, Void, TimeAccel, TimeStop }
```

---

### HiddenArea.cs

```csharp
using UnityEngine;

public class HiddenArea : MonoBehaviour
{
    [Header("Hidden Settings")]
    public string areaId;
    public DiscoverCondition condition;
    public int checkCount = 3; // 조사 횟수
    
    [Header("Reveal")]
    [SerializeField] private GameObject hiddenContent;
    [SerializeField] private GameObject reward;
    
    private int _currentChecks = 0;
    private bool _isRevealed = false;
    
    public void Check()
    {
        if (_isRevealed) return;
        
        _currentChecks++;
        
        if (_currentChecks >= checkCount)
        {
            Reveal();
        }
        else
        {
            UIManager.Instance.ShowMessage($"뭔가 있는 것 같다... ({_currentChecks}/{checkCount})");
        }
    }
    
    public void CheckWithRewind()
    {
        if (condition == DiscoverCondition.Rewind)
        {
            Reveal();
        }
    }
    
    private void Reveal()
    {
        _isRevealed = true;
        hiddenContent.SetActive(true);
        
        if (reward != null)
            reward.SetActive(true);
        
        // 기록
        SaveSystem.Load().discoveredAreas.Add(areaId);
    }
}

public enum DiscoverCondition { Check, Rewind, TimeLayer, SpecificTime }
```

---

## Phase 3 체크리스트

### 맵 시스템
- [ ] 타일맵 설정
- [ ] RoomController.cs
- [ ] Door.cs
- [ ] 씬 전환
- [ ] Cinemachine 카메라

### 챕터 맵
- [ ] 프롤로그 (다락방)
- [ ] 1장 (미래 도시)
- [ ] 2장 (과거 마을)
- [ ] 3장 (대시계)
- [ ] 4장 (공허)

### 퍼즐/기믹
- [ ] 시간 역전 퍼즐
- [ ] 과거/현재 레이어
- [ ] 환경 위험요소
- [ ] 숨겨진 구역

---

## 다음 단계
Phase 3 완료 후 [Phase 4: 스토리/연출](./17_phase4_story.md)으로 진행
