# Phase 2: 전투 시스템

> 기간: 4주 | 적 AI, 보스, 데미지 시스템 구현

---

## 목표
- 적 베이스 클래스 및 AI 구현
- 4종 일반 적 구현
- 보스 시스템 구현
- 데미지 계산 및 상태이상

---

## Week 1-2: 적 시스템

### EnemyBase.cs

```csharp
using UnityEngine;
using System.Collections;

public abstract class EnemyBase : MonoBehaviour, IDamageable
{
    [Header("Stats - from 08_balance_sheet.md")]
    public EnemyData data;
    
    protected int currentHP;
    protected float currentSpeed;
    protected bool isSlowed;
    
    protected Transform target;
    protected Animator animator;
    protected Rigidbody2D rb;
    
    public bool IsDead => currentHP <= 0;
    
    protected virtual void Awake()
    {
        animator = GetComponent<Animator>();
        rb = GetComponent<Rigidbody2D>();
    }
    
    protected virtual void Start()
    {
        currentHP = data.maxHP;
        currentSpeed = data.moveSpeed;
        target = GameManager.Instance.Player.transform;
    }
    
    public virtual void TakeDamage(int amount)
    {
        if (IsDead) return;
        
        currentHP -= amount;
        
        // 피격 연출
        StartCoroutine(FlashRed());
        
        if (currentHP <= 0)
        {
            Die();
        }
    }
    
    protected virtual void Die()
    {
        // 드롭
        DropLoot();
        
        // 이벤트 발행
        EventBus.Publish(new OnEnemyDefeated { 
            EnemyId = data.enemyId, 
            ShardsDrop = data.shardsDrop 
        });
        
        // 사망 애니메이션 후 제거
        animator.SetTrigger("Die");
        Destroy(gameObject, 1f);
    }
    
    protected virtual void DropLoot()
    {
        // 시간 파편 드롭
        for (int i = 0; i < data.shardsDrop; i++)
        {
            var shard = ObjectPool.Instance.Spawn("TimeShard", 
                transform.position + Random.insideUnitSphere * 0.5f, 
                Quaternion.identity);
        }
        
        // 아이템 드롭 (확률)
        if (Random.value < data.itemDropRate)
        {
            // 아이템 드롭 로직
        }
    }
    
    public void ApplySlowEffect(float rate, float duration)
    {
        StartCoroutine(SlowRoutine(rate, duration));
    }
    
    private IEnumerator SlowRoutine(float rate, float duration)
    {
        isSlowed = true;
        float originalSpeed = currentSpeed;
        currentSpeed *= rate;
        
        yield return new WaitForSeconds(duration);
        
        currentSpeed = originalSpeed;
        isSlowed = false;
    }
    
    private IEnumerator FlashRed()
    {
        var sr = GetComponent<SpriteRenderer>();
        sr.color = Color.red;
        yield return new WaitForSeconds(0.1f);
        sr.color = Color.white;
    }
    
    // 추상 메서드 - 각 적이 구현
    protected abstract void UpdateAI();
    protected abstract void Attack();
}
```

---

### EnemyData.cs (ScriptableObject)

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "NewEnemy", menuName = "ChronosGear/EnemyData")]
public class EnemyData : ScriptableObject
{
    [Header("Identity")]
    public string enemyId;
    public string enemyName;
    
    [Header("Stats - from 08_balance_sheet.md")]
    public int maxHP;
    public int atk;
    public int def;
    public float moveSpeed;
    
    [Header("Drops - from 09_economy.md")]
    public int shardsDrop;
    public float itemDropRate;
    
    [Header("Combat")]
    public float attackRange;
    public float attackCooldown;
    public float detectionRange;
    
    [Header("Weakness")]
    public SkillType weakness;
    public float weaknessMultiplier = 1.5f;
}

public enum SkillType { None, ChronoShift, TimeAnchor, Rewind, EchoClone }
```

---

### 틱톡커 (Tiktoker)

```csharp
public class Tiktoker : EnemyBase
{
    [Header("Tiktoker Specific")]
    [SerializeField] private float dashSpeed = 8f;
    [SerializeField] private float dashDuration = 0.3f;
    
    private enum State { Idle, Chase, Attack, Dash }
    private State _state = State.Idle;
    
    private float _attackCooldown;
    
    private void Update()
    {
        if (IsDead) return;
        UpdateAI();
    }
    
    protected override void UpdateAI()
    {
        float distance = Vector2.Distance(transform.position, target.position);
        
        switch (_state)
        {
            case State.Idle:
                if (distance < data.detectionRange)
                    _state = State.Chase;
                break;
                
            case State.Chase:
                ChaseTarget();
                if (distance < data.attackRange)
                    _state = State.Attack;
                else if (distance > data.detectionRange * 1.5f)
                    _state = State.Idle;
                break;
                
            case State.Attack:
                if (_attackCooldown <= 0)
                    Attack();
                else
                    _attackCooldown -= Time.deltaTime;
                break;
        }
    }
    
    private void ChaseTarget()
    {
        Vector2 dir = (target.position - transform.position).normalized;
        rb.MovePosition(rb.position + dir * currentSpeed * Time.deltaTime);
        
        // 방향 전환
        transform.localScale = new Vector3(dir.x > 0 ? 1 : -1, 1, 1);
    }
    
    protected override void Attack()
    {
        animator.SetTrigger("Attack");
        _attackCooldown = data.attackCooldown;
        
        // 대시 공격
        StartCoroutine(DashAttack());
    }
    
    private IEnumerator DashAttack()
    {
        _state = State.Dash;
        
        Vector2 dir = (target.position - transform.position).normalized;
        float elapsed = 0f;
        
        while (elapsed < dashDuration)
        {
            rb.MovePosition(rb.position + dir * dashSpeed * Time.deltaTime);
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        _state = State.Chase;
    }
    
    // 애니메이션 이벤트에서 호출
    public void OnAttackHit()
    {
        var player = GameManager.Instance.Player.Stats;
        if (Vector2.Distance(transform.position, target.position) < 1.5f)
        {
            player.TakeDamage(data.atk);
        }
    }
}
```

---

### 보이드 글리치 (VoidGlitch)

```csharp
public class VoidGlitch : EnemyBase
{
    [Header("Glitch Specific")]
    [SerializeField] private float teleportCooldown = 3f;
    [SerializeField] private float teleportRange = 5f;
    [SerializeField] private GameObject projectilePrefab;
    
    private float _teleportTimer;
    private bool _isPhysicsImmune = true; // 물리 면역
    
    public override void TakeDamage(int amount)
    {
        // 물리 공격은 무효 (시간 스킬만 유효)
        if (_isPhysicsImmune)
        {
            // 무효 연출
            Debug.Log("Physical attack ineffective!");
            return;
        }
        
        base.TakeDamage(amount);
    }
    
    public void TakeSkillDamage(int amount, SkillType skill)
    {
        _isPhysicsImmune = false;
        
        if (skill == data.weakness)
            amount = Mathf.RoundToInt(amount * data.weaknessMultiplier);
        
        base.TakeDamage(amount);
        
        StartCoroutine(ResetImmunity());
    }
    
    private IEnumerator ResetImmunity()
    {
        yield return new WaitForSeconds(2f);
        _isPhysicsImmune = true;
    }
    
    protected override void UpdateAI()
    {
        _teleportTimer -= Time.deltaTime;
        
        if (_teleportTimer <= 0)
        {
            Teleport();
            _teleportTimer = teleportCooldown;
        }
        
        // 원거리 공격
        if (Vector2.Distance(transform.position, target.position) < data.detectionRange)
        {
            Attack();
        }
    }
    
    private void Teleport()
    {
        Vector2 randomOffset = Random.insideUnitCircle * teleportRange;
        Vector2 newPos = (Vector2)target.position + randomOffset;
        
        // 텔레포트 연출
        animator.SetTrigger("Teleport");
        transform.position = newPos;
    }
    
    protected override void Attack()
    {
        if (_attackCooldown > 0) return;
        
        animator.SetTrigger("Attack");
        
        // 투사체 발사
        var proj = Instantiate(projectilePrefab, transform.position, Quaternion.identity);
        var projScript = proj.GetComponent<Projectile>();
        projScript.Initialize(target.position, data.atk);
        
        _attackCooldown = data.attackCooldown;
    }
    
    private float _attackCooldown;
}
```

---

## Week 3-4: 보스 시스템

### BossBase.cs

```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public abstract class BossBase : EnemyBase
{
    [Header("Boss Settings")]
    [SerializeField] protected List<BossPhase> phases;
    [SerializeField] protected BossHealthBar healthBar;
    
    protected int currentPhaseIndex = 0;
    protected BossPhase CurrentPhase => phases[currentPhaseIndex];
    
    protected bool isTransitioning = false;
    
    protected override void Start()
    {
        base.Start();
        healthBar.Initialize(data.maxHP);
        EnterPhase(0);
    }
    
    public override void TakeDamage(int amount)
    {
        if (isTransitioning) return;
        
        base.TakeDamage(amount);
        healthBar.UpdateHealth(currentHP);
        
        // 페이즈 전환 체크
        CheckPhaseTransition();
    }
    
    protected virtual void CheckPhaseTransition()
    {
        if (currentPhaseIndex >= phases.Count - 1) return;
        
        float hpRatio = (float)currentHP / data.maxHP;
        if (hpRatio <= phases[currentPhaseIndex + 1].hpThreshold)
        {
            StartCoroutine(TransitionToNextPhase());
        }
    }
    
    protected virtual IEnumerator TransitionToNextPhase()
    {
        isTransitioning = true;
        
        // 페이즈 전환 연출
        animator.SetTrigger("PhaseTransition");
        yield return new WaitForSeconds(CurrentPhase.transitionDuration);
        
        currentPhaseIndex++;
        EnterPhase(currentPhaseIndex);
        
        isTransitioning = false;
    }
    
    protected virtual void EnterPhase(int phaseIndex)
    {
        Debug.Log($"Entering Phase {phaseIndex + 1}");
        
        // 페이즈별 초기화
        CurrentPhase.OnEnter?.Invoke();
    }
    
    protected override void UpdateAI()
    {
        if (isTransitioning || IsDead) return;
        
        CurrentPhase.UpdateBehavior(this);
    }
}

[System.Serializable]
public class BossPhase
{
    public string phaseName;
    [Range(0f, 1f)] public float hpThreshold;
    public float transitionDuration = 3f;
    public List<BossPattern> patterns;
    public System.Action OnEnter;
    
    private int _currentPatternIndex = 0;
    
    public void UpdateBehavior(BossBase boss)
    {
        // 패턴 순환
        var pattern = patterns[_currentPatternIndex];
        pattern.Execute(boss);
        
        if (pattern.IsComplete)
        {
            _currentPatternIndex = (_currentPatternIndex + 1) % patterns.Count;
            pattern.Reset();
        }
    }
}

public abstract class BossPattern : ScriptableObject
{
    public abstract void Execute(BossBase boss);
    public abstract bool IsComplete { get; }
    public abstract void Reset();
}
```

---

### 시간 먹는 자 (TimeDevourer)

```csharp
public class TimeDevourer : BossBase
{
    [Header("Devourer Skills")]
    [SerializeField] private float chargeSpeed = 12f;
    [SerializeField] private float absorbRange = 3f;
    [SerializeField] private GameObject projectilePrefab;
    
    private void Awake()
    {
        base.Awake();
        
        // 페이즈 설정
        phases = new List<BossPhase>
        {
            new BossPhase
            {
                phaseName = "Phase 1",
                hpThreshold = 1f,
                patterns = new List<BossPattern>
                {
                    // 패턴 추가
                }
            },
            new BossPhase
            {
                phaseName = "Phase 2",
                hpThreshold = 0.5f,
                transitionDuration = 3f,
                patterns = new List<BossPattern>
                {
                    // 분열 패턴 추가
                }
            }
        };
    }
    
    // 패턴 1: 돌진
    public void ExecuteCharge()
    {
        StartCoroutine(ChargeRoutine());
    }
    
    private IEnumerator ChargeRoutine()
    {
        animator.SetTrigger("ChargeWarning");
        yield return new WaitForSeconds(1f); // 경고
        
        Vector2 dir = (target.position - transform.position).normalized;
        animator.SetTrigger("Charge");
        
        float duration = 0.5f;
        float elapsed = 0f;
        
        while (elapsed < duration)
        {
            rb.MovePosition(rb.position + dir * chargeSpeed * Time.deltaTime);
            elapsed += Time.deltaTime;
            yield return null;
        }
    }
    
    // 패턴 2: 시간 흡수
    public void ExecuteAbsorb()
    {
        StartCoroutine(AbsorbRoutine());
    }
    
    private IEnumerator AbsorbRoutine()
    {
        animator.SetTrigger("Absorb");
        
        float duration = 3f;
        float elapsed = 0f;
        
        while (elapsed < duration)
        {
            // 플레이어가 범위 내면 끌어당김
            float dist = Vector2.Distance(transform.position, target.position);
            if (dist < absorbRange)
            {
                Vector2 dir = (transform.position - target.position).normalized;
                target.position += (Vector3)(dir * 2f * Time.deltaTime);
                
                // TP 감소
                GameManager.Instance.Player.Stats.UseTP(1);
            }
            
            elapsed += Time.deltaTime;
            yield return null;
        }
    }
    
    // 패턴 3: 투사체
    public void ExecuteProjectile()
    {
        animator.SetTrigger("Shoot");
        
        for (int i = 0; i < 8; i++)
        {
            float angle = i * 45f;
            Vector2 dir = Quaternion.Euler(0, 0, angle) * Vector2.up;
            
            var proj = Instantiate(projectilePrefab, transform.position, Quaternion.identity);
            proj.GetComponent<Projectile>().Initialize(dir, data.atk);
        }
    }
    
    // 페이즈 2: 분열
    protected override IEnumerator TransitionToNextPhase()
    {
        yield return base.TransitionToNextPhase();
        
        if (currentPhaseIndex == 1)
        {
            // 분열 연출
            SpawnMinions(2);
        }
    }
    
    private void SpawnMinions(int count)
    {
        for (int i = 0; i < count; i++)
        {
            Vector2 offset = Random.insideUnitCircle * 2f;
            // 미니 버전 스폰
        }
    }
}
```

---

### DamageCalculator.cs

```csharp
public static class DamageCalculator
{
    // 08_balance_sheet.md 참조
    public static int Calculate(int atk, float skillMultiplier, DamageBonus bonus, int targetDef)
    {
        float totalBonus = 1f;
        
        if (bonus.HasFlag(DamageBonus.BulletTime)) totalBonus *= 1.2f;
        if (bonus.HasFlag(DamageBonus.JustParry)) totalBonus *= 1.5f;
        if (bonus.HasFlag(DamageBonus.EchoCoop)) totalBonus *= 1.3f;
        if (bonus.HasFlag(DamageBonus.Critical)) totalBonus *= 2.0f;
        
        int raw = Mathf.RoundToInt(atk * skillMultiplier * totalBonus);
        int final = Mathf.Max(1, raw - targetDef);
        
        return final;
    }
    
    public static bool RollCritical(float baseChance, bool hasInsight)
    {
        if (hasInsight) return true;
        return Random.value < baseChance;
    }
}

[System.Flags]
public enum DamageBonus
{
    None = 0,
    BulletTime = 1,
    JustParry = 2,
    EchoCoop = 4,
    Critical = 8
}
```

---

## Phase 2 체크리스트

### 적 시스템
- [ ] EnemyBase.cs 구현
- [ ] EnemyData SO 생성
- [ ] 틱톡커 구현
- [ ] 과거의 망령 구현
- [ ] 보이드 글리치 구현
- [ ] 시간 먹는 자 구현
- [ ] 적 스폰 시스템

### 보스 시스템
- [ ] BossBase.cs 구현
- [ ] 페이즈 전환 시스템
- [ ] 시간 먹는 자 (1장 보스)
- [ ] 보스 패턴 구현
- [ ] 보스 체력바 UI

### 데미지 시스템
- [ ] DamageCalculator.cs
- [ ] 상태이상 시스템
- [ ] 히트박스/허트박스

---

## 다음 단계
Phase 2 완료 후 [Phase 3: 레벨 디자인](./16_phase3_level.md)으로 진행
