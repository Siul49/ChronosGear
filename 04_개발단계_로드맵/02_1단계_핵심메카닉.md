# Phase 1: 코어 메카닉

> 기간: 6주 | 플레이어 시스템 및 시간 스킬 구현

---

## 목표
- 8방향 이동 및 기본 공격 구현
- 4개의 시간 스킬 구현
- 노화 시스템 구현
- 저스트 타이밍 시스템 구현

---

## Week 1-2: 플레이어 기본

### Input 설정 (New Input System)

#### PlayerInputActions.inputactions
```json
{
    "maps": [
        {
            "name": "Player",
            "actions": [
                { "name": "Move", "type": "Value", "expectedControlType": "Vector2" },
                { "name": "Attack", "type": "Button" },
                { "name": "Dodge", "type": "Button" },
                { "name": "Block", "type": "Button" },
                { "name": "ChronoShift", "type": "Button" },
                { "name": "TimeAnchor", "type": "Button" },
                { "name": "Rewind", "type": "Button" },
                { "name": "EchoClone", "type": "Button" },
                { "name": "Interact", "type": "Button" },
                { "name": "Pause", "type": "Button" }
            ]
        }
    ]
}
```

#### 키 바인딩
| 액션 | 키보드 | 게임패드 |
|------|--------|----------|
| Move | WASD | Left Stick |
| Attack | X / LMB | Square / X |
| Dodge | Space | Circle / B |
| Block | C | L1 / LB |
| ChronoShift | Shift | R2 / RT |
| TimeAnchor | Q | L2 / LT |
| Rewind | E | L1 / LB |
| EchoClone | R | R1 / RB |
| Interact | F | Triangle / Y |
| Pause | ESC | Options / Start |

---

### PlayerController.cs

```csharp
using UnityEngine;
using UnityEngine.InputSystem;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    [Header("Movement")]
    [SerializeField] private float moveSpeed = 5f;
    
    [Header("References")]
    [SerializeField] private Animator animator;
    
    private Rigidbody2D _rb;
    private Vector2 _moveInput;
    private Vector2 _lastDirection = Vector2.down;
    
    private PlayerStats _stats;
    private PlayerCombat _combat;
    private PlayerSkills _skills;
    
    // 상태
    public bool CanMove { get; set; } = true;
    public bool IsAttacking { get; private set; }
    public bool IsDodging { get; private set; }
    
    private void Awake()
    {
        _rb = GetComponent<Rigidbody2D>();
        _stats = GetComponent<PlayerStats>();
        _combat = GetComponent<PlayerCombat>();
        _skills = GetComponent<PlayerSkills>();
    }
    
    private void FixedUpdate()
    {
        if (CanMove && !IsAttacking && !IsDodging)
        {
            Move();
        }
    }
    
    private void Move()
    {
        _rb.MovePosition(_rb.position + _moveInput * moveSpeed * Time.fixedDeltaTime);
        
        if (_moveInput != Vector2.zero)
        {
            _lastDirection = _moveInput.normalized;
            UpdateAnimator();
        }
    }
    
    private void UpdateAnimator()
    {
        animator.SetFloat("MoveX", _lastDirection.x);
        animator.SetFloat("MoveY", _lastDirection.y);
        animator.SetBool("IsMoving", _moveInput.magnitude > 0.1f);
    }
    
    // Input System 콜백
    public void OnMove(InputAction.CallbackContext context)
    {
        _moveInput = context.ReadValue<Vector2>();
    }
    
    public void OnAttack(InputAction.CallbackContext context)
    {
        if (context.performed && CanMove)
        {
            _combat.Attack();
        }
    }
    
    public void OnDodge(InputAction.CallbackContext context)
    {
        if (context.performed && CanMove)
        {
            StartCoroutine(DodgeRoutine());
        }
    }
    
    private System.Collections.IEnumerator DodgeRoutine()
    {
        IsDodging = true;
        // 회피 로직
        yield return new WaitForSeconds(0.3f);
        IsDodging = false;
    }
}
```

---

### PlayerStats.cs

```csharp
using UnityEngine;

public class PlayerStats : MonoBehaviour
{
    [Header("Base Stats - from 08_balance_sheet.md")]
    public int MaxHP = 100;
    public int MaxTP = 100;
    public int ATK = 10;
    public int DEF = 5;
    public float SPD = 1f;
    
    [Header("Current Stats")]
    public int CurrentHP;
    public int CurrentTP;
    
    [Header("Aging - 노화 시스템")]
    [Range(0f, 100f)]
    public float AgingGauge = 0f;
    
    public AgingStage CurrentStage => GetAgingStage();
    
    private void Start()
    {
        CurrentHP = MaxHP;
        CurrentTP = MaxTP;
        ApplyAgingModifiers();
    }
    
    public void TakeDamage(int amount)
    {
        int finalDamage = Mathf.Max(1, amount - DEF);
        CurrentHP = Mathf.Max(0, CurrentHP - finalDamage);
        
        EventBus.Publish(new OnPlayerDamaged { 
            Damage = finalDamage, 
            CurrentHP = this.CurrentHP 
        });
        
        if (CurrentHP <= 0) Die();
    }
    
    public bool UseTP(int amount)
    {
        if (CurrentTP < amount) return false;
        CurrentTP -= amount;
        return true;
    }
    
    public void AddTP(int amount)
    {
        CurrentTP = Mathf.Min(CurrentTP + amount, MaxTP);
    }
    
    public void AddAging(float amount)
    {
        float oldValue = AgingGauge;
        AgingGauge = Mathf.Clamp(AgingGauge + amount, 0f, 100f);
        
        EventBus.Publish(new OnAgingChanged { 
            OldValue = oldValue, 
            NewValue = AgingGauge 
        });
        
        ApplyAgingModifiers();
    }
    
    private AgingStage GetAgingStage()
    {
        if (AgingGauge < 25f) return AgingStage.Young;
        if (AgingGauge < 50f) return AgingStage.Adult;
        if (AgingGauge < 75f) return AgingStage.Middle;
        return AgingStage.Old;
    }
    
    private void ApplyAgingModifiers()
    {
        // 08_balance_sheet.md 참조
        switch (CurrentStage)
        {
            case AgingStage.Young:
                MaxHP = 100; MaxTP = 100; ATK = 10; DEF = 5; SPD = 1f;
                break;
            case AgingStage.Adult:
                MaxHP = 120; MaxTP = 130; ATK = 12; DEF = 7; SPD = 0.95f;
                break;
            case AgingStage.Middle:
                MaxHP = 140; MaxTP = 160; ATK = 15; DEF = 10; SPD = 0.85f;
                break;
            case AgingStage.Old:
                MaxHP = 160; MaxTP = 200; ATK = 18; DEF = 12; SPD = 0.70f;
                break;
        }
    }
    
    private void Die()
    {
        Debug.Log("Player Died");
        // 사망 처리
    }
}

public enum AgingStage { Young, Adult, Middle, Old }
```

---

### PlayerCombat.cs

```csharp
using UnityEngine;

public class PlayerCombat : MonoBehaviour
{
    [Header("Combo Settings - from 10_skill_specs.md")]
    [SerializeField] private float comboWindow = 0.5f;
    [SerializeField] private Transform attackPoint;
    [SerializeField] private float attackRange = 1.5f;
    [SerializeField] private LayerMask enemyLayers;
    
    private PlayerStats _stats;
    private PlayerController _controller;
    private Animator _animator;
    
    private int _comboCount = 0;
    private float _lastAttackTime;
    
    // 데미지 배율 (10_skill_specs.md)
    private float[] _comboDamage = { 1.0f, 1.5f, 2.5f };
    
    private void Awake()
    {
        _stats = GetComponent<PlayerStats>();
        _controller = GetComponent<PlayerController>();
        _animator = GetComponent<Animator>();
    }
    
    public void Attack()
    {
        // 콤보 체크
        if (Time.time - _lastAttackTime > comboWindow)
        {
            _comboCount = 0;
        }
        
        _lastAttackTime = Time.time;
        _controller.IsAttacking = true;
        
        // 애니메이션
        _animator.SetTrigger($"Attack{_comboCount + 1}");
        
        // 데미지 계산
        int damage = Mathf.RoundToInt(_stats.ATK * _comboDamage[_comboCount]);
        
        // 히트 감지
        Collider2D[] hits = Physics2D.OverlapCircleAll(
            attackPoint.position, attackRange, enemyLayers);
        
        foreach (var hit in hits)
        {
            var enemy = hit.GetComponent<IDamageable>();
            enemy?.TakeDamage(damage);
        }
        
        // 콤보 증가
        _comboCount = (_comboCount + 1) % 3;
    }
    
    // 애니메이션 이벤트에서 호출
    public void OnAttackEnd()
    {
        _controller.IsAttacking = false;
    }
}

public interface IDamageable
{
    void TakeDamage(int amount);
}
```

---

## Week 3-4: 시간 스킬

### SkillData.cs (ScriptableObject)

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "NewSkill", menuName = "ChronosGear/SkillData")]
public class SkillData : ScriptableObject
{
    [Header("Basic Info")]
    public string skillId;
    public string skillName;
    public Sprite icon;
    
    [Header("Cost - from 08_balance_sheet.md")]
    public int tpCost;
    public float agingCost;
    
    [Header("Timing - from 10_skill_specs.md")]
    public int startupFrames;
    public int activeFrames;
    public int recoveryFrames;
    public float cooldown;
    
    [Header("Stats")]
    public float range;
    public float duration;
    public float damageMultiplier;
    
    [Header("Upgrade")]
    public int maxLevel = 4;
    public int[] upgradeCosts; // from 09_economy.md
}
```

---

### ChronoShift.cs (크로노 시프트)

```csharp
using System.Collections;
using UnityEngine;

public class ChronoShift : SkillBase
{
    [Header("Shift Settings - from 10_skill_specs.md")]
    [SerializeField] private float shiftDistance = 3f;
    [SerializeField] private float iframeDuration = 0.2f;
    [SerializeField] private float justDodgeWindow = 0.15f;
    
    [Header("Consecutive Use Penalty")]
    [SerializeField] private int baseCost = 15;
    [SerializeField] private int penaltyPerUse = 10;
    [SerializeField] private float penaltyResetTime = 1f;
    
    private int _consecutiveUses = 0;
    private float _lastUseTime;
    
    public override void Execute()
    {
        if (!CanUse()) return;
        
        // 연속 사용 페널티 계산
        if (Time.time - _lastUseTime > penaltyResetTime)
            _consecutiveUses = 0;
        
        int cost = baseCost + (_consecutiveUses * penaltyPerUse);
        if (!stats.UseTP(cost)) return;
        
        _consecutiveUses++;
        _lastUseTime = Time.time;
        
        StartCoroutine(ShiftRoutine());
    }
    
    private IEnumerator ShiftRoutine()
    {
        isActive = true;
        
        // 무적 프레임 시작
        player.gameObject.layer = LayerMask.NameToLayer("Invincible");
        
        // 저스트 회피 체크
        bool justDodge = CheckJustDodge();
        
        // 이동
        Vector2 direction = player.LastDirection;
        Vector2 targetPos = (Vector2)transform.position + direction * shiftDistance;
        
        float elapsed = 0f;
        Vector2 startPos = transform.position;
        
        while (elapsed < iframeDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / iframeDuration;
            transform.position = Vector2.Lerp(startPos, targetPos, t);
            yield return null;
        }
        
        // 무적 해제
        player.gameObject.layer = LayerMask.NameToLayer("Player");
        
        // 저스트 회피 성공 시
        if (justDodge)
        {
            TriggerBulletTime();
            stats.AddTP(30); // TP 회복
        }
        
        // 노화 증가
        stats.AddAging(skillData.agingCost);
        
        isActive = false;
    }
    
    private bool CheckJustDodge()
    {
        // 주변 적 공격 판정 체크
        Collider2D[] threats = Physics2D.OverlapCircleAll(
            transform.position, 2f, LayerMask.GetMask("EnemyAttack"));
        
        return threats.Length > 0;
    }
    
    private void TriggerBulletTime()
    {
        Time.timeScale = 0.3f;
        StartCoroutine(ResetTimeScale(2f));
    }
    
    private IEnumerator ResetTimeScale(float duration)
    {
        yield return new WaitForSecondsRealtime(duration);
        Time.timeScale = 1f;
    }
}
```

---

### TimeAnchor.cs (타임 앵커)

```csharp
using System.Collections;
using UnityEngine;

public class TimeAnchor : SkillBase
{
    [Header("Anchor Settings - from 10_skill_specs.md")]
    [SerializeField] private float fieldRadius = 2.5f;
    [SerializeField] private float slowRate = 0.1f; // 90% 감속
    [SerializeField] private float duration = 4f;
    [SerializeField] private GameObject anchorPrefab;
    
    private GameObject _currentAnchor;
    
    public override void Execute()
    {
        if (!CanUse()) return;
        if (!stats.UseTP(skillData.tpCost)) return;
        
        // 기존 앵커 제거
        if (_currentAnchor != null)
            Destroy(_currentAnchor);
        
        // 새 앵커 생성
        _currentAnchor = Instantiate(anchorPrefab, transform.position, Quaternion.identity);
        
        StartCoroutine(AnchorRoutine());
    }
    
    private IEnumerator AnchorRoutine()
    {
        isActive = true;
        float elapsed = 0f;
        
        while (elapsed < duration && _currentAnchor != null)
        {
            elapsed += Time.deltaTime;
            
            // 범위 내 적 감속
            SlowEnemiesInRange();
            
            yield return null;
        }
        
        if (_currentAnchor != null)
            Destroy(_currentAnchor);
        
        // 노화 증가
        stats.AddAging(skillData.agingCost);
        
        isActive = false;
    }
    
    private void SlowEnemiesInRange()
    {
        Collider2D[] enemies = Physics2D.OverlapCircleAll(
            _currentAnchor.transform.position, 
            fieldRadius, 
            LayerMask.GetMask("Enemy"));
        
        foreach (var enemy in enemies)
        {
            var ai = enemy.GetComponent<EnemyBase>();
            if (ai != null)
            {
                ai.ApplySlowEffect(slowRate, Time.deltaTime + 0.1f);
            }
        }
    }
}
```

---

### Rewind.cs (리와인드)

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Rewind : SkillBase
{
    [Header("Rewind Settings - from 10_skill_specs.md")]
    [SerializeField] private float recordDuration = 3f;
    [SerializeField] private float rewindRange = 3f;
    [SerializeField] private int selfCostMultiplier = 2;
    [SerializeField] private float selfAgingPenalty = 5f;
    
    private Queue<RewindState> _selfStates = new();
    private float _recordInterval = 0.05f;
    
    private void LateUpdate()
    {
        // 상태 기록 (매 프레임)
        RecordState();
    }
    
    private void RecordState()
    {
        _selfStates.Enqueue(new RewindState
        {
            position = transform.position,
            hp = stats.CurrentHP,
            timestamp = Time.time
        });
        
        // 오래된 상태 제거
        while (_selfStates.Count > 0 && 
               Time.time - _selfStates.Peek().timestamp > recordDuration)
        {
            _selfStates.Dequeue();
        }
    }
    
    public override void Execute()
    {
        if (!CanUse()) return;
        if (!stats.UseTP(skillData.tpCost)) return;
        
        // 전방 오브젝트 리와인드
        RewindObjectsInRange();
        
        stats.AddAging(skillData.agingCost);
    }
    
    public void ExecuteSelfRewind()
    {
        // 자기 자신 리와인드 (홀드 1초)
        int cost = skillData.tpCost * selfCostMultiplier;
        if (!stats.UseTP(cost)) return;
        
        if (_selfStates.Count > 0)
        {
            var oldestState = GetOldestState();
            transform.position = oldestState.position;
            stats.CurrentHP = oldestState.hp;
        }
        
        stats.AddAging(skillData.agingCost + selfAgingPenalty);
        _selfStates.Clear();
    }
    
    private void RewindObjectsInRange()
    {
        Collider2D[] objects = Physics2D.OverlapCircleAll(
            transform.position + transform.up * 1.5f,
            rewindRange,
            LayerMask.GetMask("Rewindable", "EnemyProjectile"));
        
        foreach (var obj in objects)
        {
            var rewindable = obj.GetComponent<IRewindable>();
            if (rewindable != null)
            {
                rewindable.Rewind(recordDuration);
            }
            
            // 투사체는 반사
            var projectile = obj.GetComponent<Projectile>();
            if (projectile != null)
            {
                projectile.Reflect(2f); // 2배 데미지
            }
        }
    }
    
    private RewindState GetOldestState()
    {
        RewindState oldest = default;
        foreach (var state in _selfStates)
        {
            if (oldest.timestamp == 0 || state.timestamp < oldest.timestamp)
                oldest = state;
        }
        return oldest;
    }
}

public struct RewindState
{
    public Vector3 position;
    public int hp;
    public float timestamp;
}

public interface IRewindable
{
    void Rewind(float duration);
}
```

---

### EchoClone.cs (에코 클론)

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EchoClone : SkillBase
{
    [Header("Echo Settings - from 10_skill_specs.md")]
    [SerializeField] private float recordDuration = 3f;
    [SerializeField] private float playDuration = 5f;
    [SerializeField] private float cloneDamageRatio = 0.5f;
    [SerializeField] private float coopBonus = 1.3f;
    [SerializeField] private GameObject clonePrefab;
    
    private List<CloneFrame> _recordedFrames = new();
    private float _recordInterval = 0.05f;
    private float _lastRecordTime;
    
    private GameObject _currentClone;
    
    private void Update()
    {
        // 프레임 기록
        if (Time.time - _lastRecordTime >= _recordInterval)
        {
            RecordFrame();
            _lastRecordTime = Time.time;
        }
    }
    
    private void RecordFrame()
    {
        _recordedFrames.Add(new CloneFrame
        {
            position = transform.position,
            rotation = transform.rotation,
            animState = player.Animator.GetCurrentAnimatorStateInfo(0).fullPathHash,
            normalizedTime = player.Animator.GetCurrentAnimatorStateInfo(0).normalizedTime,
            timestamp = Time.time
        });
        
        // 오래된 프레임 제거
        while (_recordedFrames.Count > 0 &&
               Time.time - _recordedFrames[0].timestamp > recordDuration)
        {
            _recordedFrames.RemoveAt(0);
        }
    }
    
    public override void Execute()
    {
        if (!CanUse()) return;
        if (!stats.UseTP(skillData.tpCost)) return;
        
        // 기존 클론 제거
        if (_currentClone != null)
            Destroy(_currentClone);
        
        // 클론 생성
        _currentClone = Instantiate(clonePrefab, transform.position, Quaternion.identity);
        var cloneController = _currentClone.GetComponent<CloneController>();
        cloneController.Initialize(_recordedFrames.ToArray(), cloneDamageRatio, coopBonus);
        
        StartCoroutine(CloneLifetime());
    }
    
    private IEnumerator CloneLifetime()
    {
        isActive = true;
        yield return new WaitForSeconds(playDuration);
        
        if (_currentClone != null)
            Destroy(_currentClone);
        
        stats.AddAging(skillData.agingCost);
        isActive = false;
    }
}

public struct CloneFrame
{
    public Vector3 position;
    public Quaternion rotation;
    public int animState;
    public float normalizedTime;
    public float timestamp;
}
```

---

## Week 5-6: 시스템 통합

### JustTimingSystem.cs

```csharp
using UnityEngine;

public class JustTimingSystem : MonoBehaviour
{
    [Header("Timing Windows - from 10_skill_specs.md")]
    [SerializeField] private float justDodgeWindow = 0.15f;  // 150ms
    [SerializeField] private float justParryWindow = 0.15f;  // 150ms
    
    // 난이도별 윈도우 (08_balance_sheet.md)
    private float[] _difficultyModifiers = { 1.67f, 1f, 0.67f, 0.33f };
    
    private int _currentDifficulty = 1; // Normal
    
    public float GetAdjustedWindow(float baseWindow)
    {
        return baseWindow * _difficultyModifiers[_currentDifficulty];
    }
    
    public bool CheckJustTiming(float attackTime, float inputTime)
    {
        float window = GetAdjustedWindow(justDodgeWindow);
        return Mathf.Abs(attackTime - inputTime) <= window;
    }
}
```

---

## Phase 1 체크리스트

### 플레이어 기본
- [ ] Input System 설정 완료
- [ ] 8방향 이동 구현
- [ ] 3타 콤보 공격 구현
- [ ] 방어/회피 구현
- [ ] 애니메이션 연동

### 시간 스킬
- [ ] 크로노 시프트 구현
- [ ] 저스트 회피 판정
- [ ] 불릿 타임 연출
- [ ] 타임 앵커 구현
- [ ] 필드 이펙트
- [ ] 리와인드 구현
- [ ] 상태 기록/복원
- [ ] 에코 클론 구현
- [ ] 행동 기록/재생

### 시스템
- [ ] 노화 시스템 구현
- [ ] 스탯 변화 적용
- [ ] 저스트 타이밍 시스템
- [ ] 난이도별 윈도우

---

## 다음 단계
Phase 1 완료 후 [Phase 2: 전투 시스템](./15_phase2_combat.md)으로 진행
