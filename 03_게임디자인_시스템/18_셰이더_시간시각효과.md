# 픽셀 쉐이더 시스템 (Pixel Shader System)

> Unity URP 기반 픽셀 쉐이더 및 포스트 프로세싱 기술 명세

---

## 왜 이 기술 스택인가? (Technical Rationale)

### URP 선택 이유

| 이유 | 설명 |
|------|------|
| **2D 최적화** | Built-in보다 2D 렌더링에 특화된 파이프라인 |
| **커스텀 렌더 패스** | ScriptableRendererFeature로 시간 이펙트 구현 용이 |
| **HDR + 블룸** | 픽셀 아트의 발광 효과에 필수적 |
| **성능** | 모바일 고려 시 HDRP보다 가벼움 |
| **미래 대응** | Unity의 표준 파이프라인으로 장기 지원 |

### 320×180 해상도 선택 이유

| 이유 | 설명 |
|------|------|
| **16:9 비율** | 현대 모니터 표준에 정확히 맞음 |
| **6× 정수 배율** | 1920×1080 출력 시 픽셀 왜곡 없음 |
| **SNES/GBA 감성** | 레트로 감성을 유지하면서 현대적 |
| **GPU 부담 최소화** | 포스트 프로세싱 비용 대폭 감소 |

### 디더링 + 팔레트 스왑 선택 이유

| 기법 | 왜 이것인가? |
|------|-------------|
| **Bayer 디더링** | 고전 픽셀 게임의 그라데이션 재현, 32색 제한에서 부드러운 전환 |
| **LUT 팔레트 스왑** | 시간대 변경(과거/미래)을 **한 프레임에** 전환 가능 |
| **세피아/네온 필터** | 과거=따뜻함, 미래=차가움이라는 직관적 시각 언어 |

### 시간 이펙트별 쉐이더 선택 이유

| 이펙트 | 기법 | 왜? |
|--------|------|-----|
| **시간 정지** | 채도 감소 + 디더링 | "색이 빠진다" = "시간이 멈춘다"의 직관적 표현 |
| **리와인드** | 글리치 + 색상 반전 | VHS 역재생 느낌, 시간 역행의 "부자연스러움" 강조 |
| **불릿 타임** | 흑백 + 비네트 | 집중력 강조, 슬로우 모션의 갑작스러움 연출 |
| **노화** | 세피아 + 그레인 | "오래된 필름" = "오래된 육체" 메타포 |

> [!IMPORTANT]
> **핵심 원칙**: 모든 시각 효과는 **게임플레이 메카닉과 연결**되어야 함.
> "멋있어서" 쓰는 이펙트 없음. 각 이펙트가 플레이어에게 **상태 정보를 전달**.

---

## 1. 렌더링 파이프라인 개요

### 기본 설정

```
[게임 렌더링]            [최종 출력]
320×180 (기준)    →    1920×1080 (6× 스케일)
     │                      ↑
     ▼                      │
[픽셀 퍼펙트 카메라]        │
     │                      │
     ▼                      │
[커스텀 쉐이더]  ──────────▶│
     │                      │
     ▼                      │
[포스트 프로세싱] ─────────▶│
```

### URP 설정

| 설정 | 값 |
|------|-----|
| Render Scale | 0.167 (320/1920) |
| Anti-Aliasing | None (픽셀 보존) |
| HDR | On (발광 효과용) |
| Upscaling Filter | Point (Nearest) |

---

## 2. 픽셀 퍼펙트 설정

### Pixel Perfect Camera 컴포넌트

```csharp
[PixelPerfectCamera Settings]
Assets Per Unit: 16
Reference Resolution: 320 × 180
Upscale Render Texture: On
Pixel Snapping: On
Crop Frame: X (Pillarbox/Letterbox)
```

### 스크립트 설정

```csharp
using UnityEngine;
using UnityEngine.Experimental.Rendering.Universal;

public class PixelPerfectSetup : MonoBehaviour
{
    [SerializeField] private PixelPerfectCamera pixelPerfect;
    
    void Start()
    {
        pixelPerfect.assetsPPU = 16;
        pixelPerfect.refResolutionX = 320;
        pixelPerfect.refResolutionY = 180;
        pixelPerfect.upscaleRT = true;
        pixelPerfect.pixelSnapping = true;
    }
}
```

---

## 3. 시간 이펙트 쉐이더

### 3.1 시간 정지 쉐이더 (Time Stop)

```hlsl
// TimeStop.shader
Shader "ChronosGear/TimeStop"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _DesatAmount ("Desaturation", Range(0, 1)) = 0.8
        _DitherScale ("Dither Scale", Float) = 8
        _TintColor ("Tint Color", Color) = (0.5, 0.3, 0.8, 1)
    }
    
    SubShader
    {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" }
        
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };
            
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float2 uv : TEXCOORD0;
                float4 screenPos : TEXCOORD1;
            };
            
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            
            float _DesatAmount;
            float _DitherScale;
            float4 _TintColor;
            
            // 4x4 Bayer 디더링 매트릭스
            static const float DitherMatrix[16] = {
                0.0/16.0, 8.0/16.0, 2.0/16.0, 10.0/16.0,
                12.0/16.0, 4.0/16.0, 14.0/16.0, 6.0/16.0,
                3.0/16.0, 11.0/16.0, 1.0/16.0, 9.0/16.0,
                15.0/16.0, 7.0/16.0, 13.0/16.0, 5.0/16.0
            };
            
            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);
                OUT.uv = IN.uv;
                OUT.screenPos = ComputeScreenPos(OUT.positionCS);
                return OUT;
            }
            
            float4 frag(Varyings IN) : SV_Target
            {
                float4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                
                // 채도 감소
                float gray = dot(col.rgb, float3(0.299, 0.587, 0.114));
                col.rgb = lerp(col.rgb, gray.xxx, _DesatAmount);
                
                // 디더링
                float2 screenUV = IN.screenPos.xy / IN.screenPos.w;
                int2 ditherCoord = int2(fmod(screenUV * _ScreenParams.xy / _DitherScale, 4));
                float dither = DitherMatrix[ditherCoord.x + ditherCoord.y * 4];
                
                // 틴트 적용
                col.rgb = lerp(col.rgb, col.rgb * _TintColor.rgb, dither * 0.3);
                
                return col;
            }
            ENDHLSL
        }
    }
}
```

#### 사용 예시
```csharp
// 타임 앵커 필드에 적용
material.SetFloat("_DesatAmount", 0.8f);
material.SetColor("_TintColor", new Color(0.5f, 0.3f, 0.8f));
```

---

### 3.2 시간 역전 쉐이더 (Rewind)

```hlsl
// TimeRewind.shader
Shader "ChronosGear/TimeRewind"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _GlitchIntensity ("Glitch", Range(0, 1)) = 0.3
        _InvertAmount ("Invert", Range(0, 1)) = 0.5
        _ScanlineFreq ("Scanlines", Float) = 100
    }
    
    SubShader
    {
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            
            float _GlitchIntensity;
            float _InvertAmount;
            float _ScanlineFreq;
            
            float4 frag(Varyings IN) : SV_Target
            {
                // 글리치 오프셋
                float glitchOffset = sin(_Time.y * 50 + IN.uv.y * 20) * _GlitchIntensity * 0.02;
                float2 uv = float2(IN.uv.x + glitchOffset, IN.uv.y);
                
                float4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);
                
                // 색상 반전
                float3 inverted = 1.0 - col.rgb;
                col.rgb = lerp(col.rgb, inverted, _InvertAmount);
                
                // 스캔라인
                float scanline = sin(IN.uv.y * _ScanlineFreq) * 0.5 + 0.5;
                col.rgb *= 0.9 + scanline * 0.1;
                
                // 색수차 (RGB 분리)
                float2 offset = float2(0.002, 0);
                col.r = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv + offset).r;
                col.b = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv - offset).b;
                
                return col;
            }
            ENDHLSL
        }
    }
}
```

---

### 3.3 과거/미래 레이어 쉐이더

#### 과거 (세피아)
```hlsl
// Sepia 쉐이더
float3 ApplySepia(float3 color)
{
    float3 sepia;
    sepia.r = dot(color, float3(0.393, 0.769, 0.189));
    sepia.g = dot(color, float3(0.349, 0.686, 0.168));
    sepia.b = dot(color, float3(0.272, 0.534, 0.131));
    return sepia;
}
```

#### 미래 (네온)
```hlsl
// Neon 쉐이더
float3 ApplyNeon(float3 color, float glowIntensity)
{
    // 채도 증가
    float gray = dot(color, float3(0.299, 0.587, 0.114));
    float3 saturated = lerp(gray.xxx, color, 1.5);
    
    // 청록 틴트
    float3 tint = float3(0.5, 1.0, 1.2);
    float3 result = saturated * tint;
    
    // 발광
    float luminance = dot(result, float3(0.299, 0.587, 0.114));
    float3 glow = result * smoothstep(0.5, 1.0, luminance) * glowIntensity;
    
    return result + glow;
}
```

---

## 4. 포스트 프로세싱

### 4.1 불릿 타임 효과

```csharp
// BulletTimeEffect.cs
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class BulletTimePostProcess : ScriptableRendererFeature
{
    class BulletTimePass : ScriptableRenderPass
    {
        private Material _material;
        private float _intensity;
        
        public void Setup(Material mat, float intensity)
        {
            _material = mat;
            _intensity = intensity;
        }
        
        public override void Execute(ScriptableRenderContext context, 
            ref RenderingData renderingData)
        {
            if (_intensity <= 0) return;
            
            var cmd = CommandBufferPool.Get("BulletTime");
            
            // 흑백 + 비네트 + 느린 모션 표시
            _material.SetFloat("_Intensity", _intensity);
            _material.SetFloat("_Desaturation", 0.8f);
            _material.SetFloat("_VignetteRadius", 0.5f);
            
            // Blit
            var source = renderingData.cameraData.renderer.cameraColorTarget;
            cmd.Blit(source, source, _material);
            
            context.ExecuteCommandBuffer(cmd);
            CommandBufferPool.Release(cmd);
        }
    }
}
```

### 4.2 노화 시각 효과

```csharp
// AgingVisualEffect.cs
public class AgingVisualEffect : MonoBehaviour
{
    [SerializeField] private Volume postVolume;
    [SerializeField] private PlayerStats playerStats;
    
    private ColorAdjustments _colorAdjust;
    private Vignette _vignette;
    private FilmGrain _grain;
    
    void Update()
    {
        float agingPercent = playerStats.AgingGauge / 100f;
        
        // 채도 감소 (노화할수록)
        _colorAdjust.saturation.value = Mathf.Lerp(0, -30, agingPercent);
        
        // 세피아 강도 (노화할수록)
        float sepiaStrength = Mathf.Lerp(0, 0.3f, agingPercent);
        _colorAdjust.colorFilter.value = Color.Lerp(Color.white, 
            new Color(1f, 0.95f, 0.85f), sepiaStrength);
        
        // 비네트 (노화할수록)
        _vignette.intensity.value = Mathf.Lerp(0.2f, 0.5f, agingPercent);
        
        // 필름 그레인 (노인 단계에서만)
        _grain.intensity.value = agingPercent > 0.75f ? 0.3f : 0f;
    }
}
```

---

## 5. 발광(Emission) 시스템

### 5.1 발광 스프라이트 설정

```hlsl
// EmissiveSprite.shader
Shader "ChronosGear/EmissiveSprite"
{
    Properties
    {
        _MainTex ("Sprite", 2D) = "white" {}
        _EmissionTex ("Emission Mask", 2D) = "black" {}
        _EmissionColor ("Emission Color", Color) = (1, 1, 1, 1)
        _EmissionIntensity ("Intensity", Float) = 2
        _PulseSpeed ("Pulse Speed", Float) = 1
    }
    
    SubShader
    {
        Tags { "Queue"="Transparent" "RenderType"="Transparent" }
        
        Pass
        {
            HLSLPROGRAM
            float4 frag(Varyings IN) : SV_Target
            {
                float4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
                float4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_MainTex, IN.uv);
                
                // 펄스 효과
                float pulse = sin(_Time.y * _PulseSpeed) * 0.5 + 0.5;
                float intensity = _EmissionIntensity * (0.8 + pulse * 0.4);
                
                // HDR 발광
                col.rgb += emission.rgb * _EmissionColor.rgb * intensity;
                
                return col;
            }
            ENDHLSL
        }
    }
}
```

### 5.2 발광 대상 오브젝트

| 오브젝트 | 발광 색상 | 강도 |
|----------|-----------|------|
| 회중시계 | 황금 | 2.0 |
| 타임 앵커 필드 | 보라 | 3.0 |
| 기어 슬롯 (활성) | 청록 | 2.5 |
| NPC 시간 감응자 | 희미한 보라 | 1.0 |
| 단서 오브젝트 | 흰색 펄스 | 1.5 |

---

## 6. 화면 전환 효과

### 6.1 시간 이동 전환

```csharp
// TimeTransition.cs
public class TimeTransition : MonoBehaviour
{
    [SerializeField] private Material transitionMaterial;
    
    public IEnumerator TransitionToTime(TimeLayer target)
    {
        float duration = 1f;
        float elapsed = 0f;
        
        // Phase 1: 글리치 증가
        while (elapsed < duration * 0.5f)
        {
            float t = elapsed / (duration * 0.5f);
            transitionMaterial.SetFloat("_GlitchIntensity", t);
            transitionMaterial.SetFloat("_ChromaticOffset", t * 0.02f);
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        // 레이어 전환
        TimeLayerSystem.Instance.SwitchToLayer(target);
        
        // Phase 2: 글리치 감소
        elapsed = 0f;
        while (elapsed < duration * 0.5f)
        {
            float t = 1f - (elapsed / (duration * 0.5f));
            transitionMaterial.SetFloat("_GlitchIntensity", t);
            transitionMaterial.SetFloat("_ChromaticOffset", t * 0.02f);
            elapsed += Time.deltaTime;
            yield return null;
        }
        
        transitionMaterial.SetFloat("_GlitchIntensity", 0);
    }
}
```

### 6.2 다이아몬드 와이프

```hlsl
// DiamondWipe.shader
float DiamondWipe(float2 uv, float progress)
{
    float2 center = float2(0.5, 0.5);
    float dist = abs(uv.x - center.x) + abs(uv.y - center.y);
    return step(dist, progress * 1.5);
}
```

---

## 7. 팔레트 스왑 시스템

### 7.1 LUT 기반 팔레트 스왑

```csharp
// PaletteSwap.cs
public class PaletteSwap : MonoBehaviour
{
    [SerializeField] private Texture2D normalPalette;
    [SerializeField] private Texture2D sepiaPalette;
    [SerializeField] private Texture2D neonPalette;
    [SerializeField] private Texture2D voidPalette;
    
    private Material _paletteSwapMaterial;
    
    public void SetPalette(TimeLayer layer)
    {
        Texture2D palette = layer switch
        {
            TimeLayer.Present => normalPalette,
            TimeLayer.Past => sepiaPalette,
            TimeLayer.Future => neonPalette,
            TimeLayer.Void => voidPalette,
            _ => normalPalette
        };
        
        _paletteSwapMaterial.SetTexture("_PaletteTex", palette);
    }
}
```

### 7.2 팔레트 텍스처 규격

```
팔레트 텍스처: 256×1 픽셀
- R 채널: 원본 색상 인덱스
- 텍스처 값: 대체할 색상

Filter Mode: Point (No Filter)
Wrap Mode: Clamp
```

---

## 8. 성능 최적화

### 8.1 쉐이더 최적화 가이드라인

| 항목 | 권장 |
|------|------|
| 복잡한 수학 | LUT로 대체 |
| 샘플링 횟수 | 최대 4회 |
| 분기 (if) | 최소화 |
| 포스트 이펙트 | 동시 2개 이하 |

### 8.2 배칭 최적화

```csharp
// 스프라이트 아틀라스 사용
// 동일 쉐이더 + 동일 텍스처 = 배칭 가능

[Header("배칭 설정")]
[SerializeField] private SpriteAtlas characterAtlas;
[SerializeField] private SpriteAtlas environmentAtlas;
[SerializeField] private SpriteAtlas effectAtlas;
```

---

## 9. 쉐이더 체크리스트

### 필수 쉐이더
- [ ] 기본 스프라이트 (외곽선 포함)
- [ ] 시간 정지 (디더링 + 채도 감소)
- [ ] 시간 역전 (글리치 + 반전)
- [ ] 발광 스프라이트
- [ ] 팔레트 스왑

### 포스트 프로세싱
- [ ] 불릿 타임
- [ ] 노화 효과
- [ ] 화면 전환
- [ ] 비네트 (동적)

### 환경 쉐이더
- [ ] 물 반사 (픽셀)
- [ ] 안개 (레이어드)
- [ ] 시차 배경
